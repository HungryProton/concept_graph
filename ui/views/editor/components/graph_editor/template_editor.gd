extends CustomGraphEdit
class_name TemplateEditor


signal generation_outdated


var _json_util = preload("res://thirdparty/json_beautifier/json_beautifier.gd")
var _template_path: String

var root: Spatial

var _save_thread: Thread
var _save_queued := false
var _timer := Timer.new()
var _template_loaded := false

var _output_nodes := [] # Final nodes of the graph
var _output := [] # Nodes generated by the graph

var _inspector: InspectorPanel
var _property_nodes := {}
var _proxy_nodes := {}


func _ready() -> void:
	Signals.safe_connect(self, "node_created", self, "_on_node_created")
	Signals.safe_connect(self, "node_deleted", self, "_on_node_deleted")
	GlobalEventBus.register_listener(self, "generation_completed", "_on_generation_completed")

	_timer.one_shot = true
	_timer.autostart = false
	Signals.safe_connect(_timer, "timeout", self, "_run_generation")
	add_child(_timer)


func _exit_tree() -> void:
	if _save_thread and _save_thread.is_active():
		_save_thread.wait_to_finish()


# Remove all nodes and connections
func clear() -> void:
	_template_loaded = false
	clear_editor()
	_output_nodes = []
	_proxy_nodes = {}


# Opens a cgraph file, reads its contents and recreate a node graph from there
func load_from_file(path: String) -> void:
	if not path or path == "":
		return
	
	clear()

	# Open the file and read the contents
	var file = File.new()
	file.open(path, File.READ)
	var json = JSON.parse(file.get_as_text())
	if not json or not json.result:
		print("Failed to parse the template file")
		return	# Template file is either empty or not a valid Json. Ignore

	# Abort if the file doesn't have node data
	var graph: Dictionary = json.result
	if not graph.has("nodes"):
		return

	# For each node found in the template file
	for node_data in graph["nodes"]:
		if node_data.has("type"):
			var type = node_data["type"]
			create_node(type, node_data, false)

	for c in graph["connections"]:
		# TODO: convert the to/from ports stored in file to actual port
		connect_node(c["from"], c["from_port"], c["to"], c["to_port"])
		var n = get_node(c["to"])
		if not n:
			print("Can't find node ", c["to"])
			continue
		n.emit_signal("connection_changed")

	#if graph.has("inspector"):
	#	_inspector.set_all_values(graph["inspector"])

	if graph.has("editor"): # Everything related to how the editor looks like
		var editor = graph["editor"]

		# Restore previous scroll offset
		if editor.has("offset_x") and editor.has("offset_y"):
			var new_offset = Vector2(editor["offset_x"], editor["offset_y"])
			call_deferred("set_scroll_ofs", new_offset) # Do that on next frame or be ignored

		# TODO
		# Restore previous camera position and zoom level
		# Restore panels width and height

	_template_path = path
	_template_loaded = true
	emit_signal("template_loaded")


func save_to_file(path: String) -> void:
	var graph := {}
	# TODO : Convert the connection_list to an ID connection list
	graph["editor"] = {
		"offset_x": scroll_offset.x,
		"offset_y": scroll_offset.y
	}
	graph["inspector"] = _inspector.get_all_values(true)
	graph["connections"] = get_connection_list()
	graph["nodes"] = []

	for c in get_children():
		if c is ConceptNode:
			var node = {}
			node["name"] = c.get_name()
			node["type"] = c.unique_id
			node["editor"] = c.export_editor_data()
			node["data"] = c.export_custom_data()
			graph["nodes"].append(node)

	if not _save_thread:
		_save_thread = Thread.new()

	if _save_thread.is_active():
		_save_queued = true
		return

	_save_thread.start(self, "_beautify_json", to_json(graph))

	yield(self, "json_ready")

	var json = _save_thread.wait_to_finish()
	var file = File.new()
	file.open(path, File.WRITE)
	file.store_string(json)
	file.close()

	if _save_queued:
		_save_queued = false
		save_to_file(path)
	
	emit_signal("template_saved")


func create_node(type, data, notify := true):
	var node: GenericNodeUi = NodeFactory.create_graph_node(type)
	if not node:
		return
	
	node.template_path = _template_path
	node.inline_vectors = Settings.get_setting(Settings.INLINE_VECTOR_FIELDS)
	add_child(node)
	node.regenerate_default_ui()
	connect_node_signals(node)
	
	# Make sure the new node is within the view
	if data.has("offset"):
		node.offset = data["offset"]
	else:
		node.offset = scroll_offset + Vector2(250, 150)
	
	if data.has("name"):
		node.name = data["name"]
	if data.has("editor"):
		node.restore_editor_data(data["editor"])

	if notify:
		emit_signal("graph_changed")
		emit_signal("simulation_outdated")


func duplicate_node(node: ConceptNode) -> GraphNode:
	var ref = NodeFactory.create_node(node.unique_id)
	add_child(ref)	# Call add child because the init is done in enter tree
	ref.restore_editor_data(node.export_editor_data())
	ref.restore_custom_data(node.export_custom_data())
	remove_child(ref) # Remove it when we're done copying the local values
	ref.name = node.name
	return ref


"""
Add custom properties in the ConceptGraph inspector panel to expose variables at the instance level.
This is used to change parameters on an instance without having to modify the template itself
(And thus modifying all the other ConceptGraph using the same template).
"""
func update_exposed_variables() -> void:
	_property_nodes = {}
	var exposed_variables = []

	for c in get_children():
		if c is ConceptNode:
			var variables = c.get_exposed_variables()
			if not variables:
				continue

			for v in variables:
				v.name = v.name.to_lower()
				v.section = v.section.to_lower()
				
				if _property_nodes.has(v.name):
					_property_nodes[v.name].append(c)
				else:
					_property_nodes[v.name] = [c]
		
			exposed_variables += variables

	emit_signal("exposed_variables_updated", exposed_variables)


"""
Called from the editor when the user changes a value from the inspector. We look for the related
property nodes associated to the updated variable and reset them. This invalidates only the nodes
on their right side.
"""
func notify_exposed_variable_change(name):
	name = name.to_lower()
	if _property_nodes.has(name):
		for c in _property_nodes[name]:
			c.reset()


"""
Proxy nodes allow the user to reference some parts of the graph in another part of the graph.
Mostly used for organization purposes
"""
func register_proxy(node, name) -> void:
	_proxy_nodes[node] = name
	emit_signal("proxy_list_updated")


func get_proxy(name) -> ConceptNode:
	for node in _proxy_nodes.keys():
		if _proxy_nodes[node] == name:
			return node
	return null


func deregister_proxy(node) -> void:
	_proxy_nodes.erase(node)
	emit_signal("proxy_list_updated")


func register_input_object(input: Spatial, graphnode: ConceptNode) -> void:
	emit_signal("input_created", input)


func deregister_input_object(input: Spatial, graphnode: ConceptNode) -> void:
	emit_signal("input_deleted", input)


"""
Get exposed variable from the inspector
"""
func get_value_from_inspector(name: String):
	return _inspector.get_value(name)


# This is the exposed API to run the simulation. This function is just there
# to avoid flooding generation request by adding a small artificial delay
# before actually sending the request.
func generate() -> void:
	_timer.start(Settings.get_setting(Settings.GENERATION_DELAY) / 1000.0)
	emit_signal("simulation_started")


# Returns the final result generated by the whole graph
func get_output() -> Array:
	return _output


# Creates a temporary template file that sent to the core to run the actual
# generation.
# Called from generate (on _timer timeout event).
func _run_generation() -> void:
	# TODO : Everything
	pass


func _beautify_json(json: String) -> String:
	var res = _json_util.beautify_json(json)
	call_deferred("emit_signal", "json_ready")
	return res


func _on_generation_completed(_data: Dictionary) -> void:
	# Answer from core
	# TODO: check if the data is serialized in the answer or stored in a file.
	pass


func _on_node_created(node) -> void:
	if node.is_final_output_node():
		_output_nodes.append(node)


func _on_node_deleted(node) -> void:
	if node.is_final_output_node():
		_output_nodes.erase(node)

	# TODO, not the most reliable way to check but the return of get_exposed_variable always
	# returns an empty array for a reason I don't understand yet.
	if "inspector" in node.unique_id:
		update_exposed_variables()


func _on_node_changed(_node := null, regenerate := false) -> void:
	# Prevent regeneration hell while loading the template from file
	if not _template_loaded:
		return

	emit_signal("graph_changed")
	if regenerate:
		emit_signal("generation_outdated")
	update()
